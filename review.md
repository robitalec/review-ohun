## Package Review

*Please check off boxes as applicable, and elaborate in comments below. Your review is not limited to these topics, as described in the reviewer guide*

-   **Briefly describe any working relationship you have (had) with the package authors.**
-   [x] As the reviewer I confirm that there are no [conflicts of interest](https://devguide.ropensci.org/policies.html#coi) for me to review this work (if you are unsure whether you are in conflict, please speak to your editor *before* starting your review).


#### Documentation

The package includes all the following forms of documentation:

-   [x] **A statement of need:** clearly stating problems the software is designed to solve and its target audience in README
-   [x] **Installation instructions:** for the development version of package and any non-standard dependencies in README
-   [x] **Vignette(s):** demonstrating major functionality that runs successfully locally
-   [x] **Function Documentation:** for all exported functions
-   [ ] **Examples:** (that run successfully locally) for all exported functions
-   [ ] **Community guidelines:** including contribution guidelines in the README or CONTRIBUTING, and DESCRIPTION with `URL`, `BugReports` and `Maintainer` (which may be autogenerated via `Authors@R`).

#### Functionality

-   [x] **Installation:** Installation succeeds as documented.
-   [ ] **Functionality:** Any functional claims of the software been confirmed.
-   [ ] **Performance:** Any performance claims of the software been confirmed.
-   [ ] **Automated tests:** Unit tests cover essential functions of the package and a reasonable range of inputs and conditions. All tests pass on the local machine.
-   [ ] **Packaging guidelines**: The package conforms to the rOpenSci packaging guidelines.

Estimated hours spent reviewing:

-   [x] Should the author(s) deem it appropriate, I agree to be acknowledged as a package reviewer ("rev" role) in the package DESCRIPTION file.

------------------------------------------------------------------------

### Review Comments

#### Documentation

**A statement of need**

Please consider adding a section to the README that 1) clarifies how `ohun` fits
into a broader workflow of working with sound event and 2) if any other packages
or approaches are available that share similar functionality to `ohun`. 

For 1), this could be adding few sentences describing what typical steps (and related 
packages) would come before and after using `ohun`. You could also add the 
workflow from the vignette to the README in this section. Consider a new user 
looking at the [Reference](https://marce10.github.io/ohun/reference/index.html) 
page on the website or the list of available functions in `ohun`... how do they
fit together?

```r
library(ohun)
#> Loading required package: tuneR
#> Loading required package: warbleR
#> Loading required package: seewave
#> Loading required package: NatureSounds
#> Loading required package: knitr
lsf.str('package:ohun')
#> consensus_detection : function (detection, by = "overlap", filter = "max", cores = 1, pb = TRUE)  
#> diagnose_detection : function (reference, detection, by.sound.file = FALSE, time.diagnostics = FALSE, 
#>     cores = 1, pb = TRUE, path = NULL, by = NULL, macro.average = FALSE, 
#>     min.overlap = 0.5)  
#> energy_detector : function (files = NULL, envelopes = NULL, path = ".", hop.size = 11.6, 
#>     wl = NULL, thinning = 1, bp = NULL, smooth = 5, threshold = 5, peak.amplitude = 0, 
#>     hold.time = 0, min.duration = 0, max.duration = Inf, cores = 1, pb = TRUE)  
#> feature_acoustic_data : function (path = ".", digits = 2)  
#> feature_reference : function (reference, path = NULL, by.sound.file = FALSE, units = c("ms", 
#>     "kHz"), digits = 2)  
#> filter_detection : function (detection, by = "overlap", filter = "max", cores = 1, pb = TRUE)  
#> get_envelopes : function (path = ".", files = NULL, bp = NULL, hop.size = 11.6, wl = NULL, 
#>     cores = 1, thinning = 1, pb = TRUE, smooth = 5, normalize = TRUE)  
#> get_templates : function (reference, acoustic.space = NULL, path = ".", n.sub.spaces = 1, 
#>     plot = TRUE, color = "#21908C4D", ...)  
#> label_detection : function (reference, detection, cores = 1, pb = TRUE, min.overlap = 0.5)  
#> label_spectro : function (wave, reference = NULL, detection = NULL, envelope = FALSE, threshold = NULL, 
#>     smooth = 5, collevels = seq(-100, 0, 5), palette = viridis::viridis, 
#>     template.correlation = NULL, line.x.position = 2, hop.size = NULL, 
#>     ...)  
#> merge_overlaps : function (X, pb = TRUE, cores = 1)  
#> optimize_energy_detector : function (reference, files = NULL, threshold = 5, peak.amplitude = 0, hop.size = 11.6, 
#>     wl = NULL, smooth = 5, hold.time = 0, min.duration = NULL, max.duration = NULL, 
#>     thinning = 1, cores = 1, pb = TRUE, by.sound.file = FALSE, bp = NULL, 
#>     path = ".", previous.output = NULL, envelopes = NULL, macro.average = FALSE, 
#>     min.overlap = 0.5)  
#> optimize_template_detector : function (template.correlations, reference, threshold, cores = 1, pb = TRUE, 
#>     by.sound.file = FALSE, previous.output = NULL, macro.average = FALSE, 
#>     min.overlap = 0.5)  
#> split_acoustic_data : function (path = ".", sgmt.dur = 10, sgmts = NULL, files = NULL, cores = 1, 
#>     pb = TRUE, only.sels = FALSE, X = NULL)  
#> summarize_diagnostic : function (diagnostic, time.diagnostics = FALSE, macro.average = FALSE)  
#> template_correlator : function (templates, files = NULL, hop.size = 11.6, wl = NULL, ovlp = 0, 
#>     wn = "hanning", cor.method = "pearson", cores = 1, path = ".", pb = TRUE, 
#>     type = "fourier", fbtype = "mel", ...)  
#> template_detector : function (template.correlations, cores = 1, threshold, pb = TRUE, verbose = TRUE)
```

For 2), as @sammlapp mentions, it's really helpful for a user to be aware of
what the options are and how they differ. The README for the `gt` package has a
good example of this here:
https://github.com/rstudio/gt#how-gt-fits-in-with-other-packages-that-generate-display-tables
